#!/usr/bin/env python3
"""Export the logistic-regression cough model to a C header for on-device inference."""
import argparse
from pathlib import Path

import numpy as np
from joblib import load

FEATURE_ORDER = [
    'len','mean','std','max','median','p90','p95','p99','skew','kurt',
    'frac_thr1','frac_thr2','peak_count','max_over_median'
]

THR1 = 2.0
THR2 = 4.0
PEAK_DISTANCE_FRAMES = 3  # distance ~0.3 s with 100 ms hop


def format_float_list(name: str, values: np.ndarray) -> str:
    elems = ', '.join(f'{float(v):.8f}f' for v in values)
    return f'static constexpr float {name}[{len(values)}] = {{{elems}}};\n'


def main() -> None:
    ap = argparse.ArgumentParser(description="Export logistic regression pipeline to Arduino header")
    ap.add_argument('--model', default=Path(__file__).parent / 'models' / 'ky038_cough_model_logreg.joblib',
                    help='Path to the trained logistic-regression pipeline joblib file')
    repo_root = Path(__file__).resolve().parents[2]
    ap.add_argument('--out', default=repo_root / 'CODES' / 'sensor_codes' / 'ky038_edge_model_params.h',
                    help='Output header path (will be overwritten)')
    args = ap.parse_args()

    pipe = load(args.model)
    try:
        imputer = pipe.named_steps['imputer']
        scaler = pipe.named_steps['scaler']
        clf = pipe.named_steps['clf']
    except Exception as exc:  # pragma: no cover - defensive guard
        raise RuntimeError('Expected a pipeline with imputer, scaler, and clf steps') from exc

    if getattr(clf, 'classes_', None) is None or clf.classes_.shape[0] != 2:
        raise RuntimeError('Logistic regression must be binary classifier with probability output')

    if len(FEATURE_ORDER) != clf.coef_.shape[1]:
        raise RuntimeError(f'Feature order mismatch: expected {len(FEATURE_ORDER)} but got {clf.coef_.shape[1]} coefficients')

    header_lines = []
    header_lines.append('// Auto-generated by export_edge_model.py; do not edit by hand.')
    header_lines.append('#pragma once')
    header_lines.append('')
    header_lines.append('// Feature extraction constants (mirror preprocess_and_train.py)')
    header_lines.append(f'static constexpr float EDGE_THR1 = {THR1:.2f}f;')
    header_lines.append(f'static constexpr float EDGE_THR2 = {THR2:.2f}f;')
    header_lines.append(f'static constexpr int EDGE_PEAK_DISTANCE_FRAMES = {PEAK_DISTANCE_FRAMES};')
    header_lines.append(f'static constexpr int EDGE_FEATURE_COUNT = {len(FEATURE_ORDER)};')
    header_lines.append('')

    header_lines.append('// Imputer fill value (SimpleImputer constant strategy)')
    fill_value = float(imputer.statistics_[0]) if imputer.statistics_.size else 0.0
    header_lines.append(f'static constexpr float EDGE_IMPUTE_FILL = {fill_value:.8f}f;')
    header_lines.append('')

    header_lines.append('// StandardScaler parameters')
    header_lines.append(format_float_list('EDGE_SCALER_MEAN', scaler.mean_))
    header_lines.append(format_float_list('EDGE_SCALER_SCALE', scaler.scale_))
    header_lines.append('')

    header_lines.append('// Logistic regression coefficients and intercept')
    header_lines.append(format_float_list('EDGE_LOGREG_COEF', clf.coef_[0]))
    header_lines.append(f'static constexpr float EDGE_LOGREG_INTERCEPT = {float(clf.intercept_[0]):.8f}f;')
    header_lines.append('')

    header_lines.append('// Feature name order for reference (optional)')
    header_lines.append('static constexpr const char* EDGE_FEATURE_NAMES[EDGE_FEATURE_COUNT] = {')
    for name in FEATURE_ORDER:
        header_lines.append(f'    "{name}",')
    header_lines.append('};')
    header_lines.append('')

    header = '\n'.join(header_lines) + '\n'
    out_path = Path(args.out)
    out_path.parent.mkdir(parents=True, exist_ok=True)
    out_path.write_text(header)
    print(f'Wrote header to {out_path}')


if __name__ == '__main__':
    main()
